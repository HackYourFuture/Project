## Outline

In the first week you'll be setting up the foundation of any software project. Using the [tech stack](https://svsg.co/how-to-choose-your-tech-stack/) you've learned about in this program (React on the front-end and Node.js/MySQL on the back-end), you'll set up the following basic folder structure:

```
client/
server/
.eslint.json (OPTIONAL)
.gitignore
.prettierrc.json (OPTIONAL)
package-lock.json
package.json
```

- **client** - Contains the source code for front-end
- **server** - Contains the source code for back-end
- **.eslint.json** - Configuration settings for [linter](https://medium.com/dailyjs/why-you-should-always-use-a-linter-and-or-pretty-formatter-bb5471115a76)
- **.gitignore** - Contains a list of file and folder names ignored by GIT when committing your code
- **.prettierrc.json** - Configuration settings for [prettier](https://github.com/prettier/prettier), a code formatter
- **package-lock.json** - An [autogenerated](https://medium.com/coinmonks/everything-you-wanted-to-know-about-package-lock-json-b81911aa8ab8) file, that keeps track of dependency installs
- **package.json** - Contains a list of all the metadata about the project (app name, dependencies, scripts, etc.)

### First steps

1. The first step is to create a project folder. The name should reflect the application name, but for now you can keep it simple:

`class<YOUR_CLASS_NUMBER>Project`

Then, using the CLI, navigate to that folder and start tracking any file changes with GIT:

`git init`

From now on you'll be able to always revert any mistakes you might have made.

2. The second step is to create a [package.json](https://medium.com/beginners-guide-to-mobile-web-development/why-package-json-npm-basics-cab3e8cd150) file.

When working in a team, it's better to use one package manager. This can either be **npm** or **yarn**. We will use **npm**.

Using the CLI, type in:

`npm init`

You'll get a list of questions about what your application will be about. After answering those it'll create a **package.json** file in your folder.
(Or type in `npm init -y` for generating it without having it ask any questions!)

3. The third step is to create the other files and folders (excluding `client/` for now) from the list.

Use the CLI or right-click to create a `server/` folder.

Also create a `.gitignore` file. For now just type in `node_modules` as the single folder to be ignored by GIT.

4. The fourth and last step is to create a remote repository. Create one on GitHub and link it to your local machine. Push all the files you have so far, and make sure you give it a meaningful commit message (like, `created basic project folder setup`).

### Creating our Node.js application base

Now that we've got the basics out of the way, we can get started with development! We'll get started with writing our server-side code first.

1. Inside the `server/` folder, create a file called `index.js`. This is where we will write the code to create our server.

Native to Node.js there's a package we can use to do this: the `http` package. Write the following code:

```js
// Filename: index.js
var http = require("http"); // This loads the http functionality in

var server = http.createServer(function requestHandler(request, response) {
  response.writeHead(200); // This gives the response a header, which is status code 200: OK
  response.end("Hi everybody!"); // This sends a message with the response to the client
});

server.listen(8080); // This starts the server, by making it actively listen (to port 8080)
```

> **Note**: `http` is [one](https://nodejs.org/docs/latest-v8.x/api/http.html#http_http) of the many built-in Node.js packages, they are available once you have installed Node.js software. For a full list and more information you can check out the [Node.js API documentation](https://nodejs.org/dist/latest-v10.x/docs/api/).

In your CLI, run the command `node server/index.js` from the root of your folder.

Open `http://localhost:8080` in your browser and you should see the 'Hi everybody!' message.

Hooray! You've just created your (tiny) HTTP server!

Every request that comes to `http://localhost:8080` is being processed by the `requestHandler` function, which results in sending 'Hi everybody!' back as a response.

> Try requesting different url like `http://localhost:8080 somethingelse` -- response will not change. To make it act differently based on requested url, we would need to write more code. But it is possible without frameworks.

However, use of the `http` module makes writing server code more complicated. For sake of simplicity and faster [feature](https://www.quora.com/How-do-you-define-a-feature-of-a-software-precisely-and-effectively) development we'll use a Node.js framework called **Express.js**.

2. Let's rewrite our server code using Express. First we have to install it, which can be done through **npm**. Execute the following from the root of the folder, using the CLI:

`npm install express`

Then replace content of `server/index.js` with the following code:

```js
// Filename: index.js
const express = require("express"); // This loads the Express functionality in

const app = express(); // This instantiates Express so we can use it

app.use(function requestHandler(request, response) {
  response.send("Hi everybody! Now it is an Express server");
});

app.listen(8080, () =>
  console.log(
    "This message makes visible to the developer that the server is running"
  )
); // This starts the server, by making it actively listen (to port 8080)
```

> **Note** - Express utilizes the http package behind the scenes.

From the root of your folder run the command `node server/index.js` to start the http-server again.

Now we should see exactly the same result with a slightly different message: 'Hi everybody! Now it is an Express server' in the browser.

> Keep in mind that it's still an HTTP server, just wrapped up in code that makes it easier for us to write server code.

3. Let's change the code to send the message to everyone who accesses our page from the root route, `'/'`. This will be `http://localhost:8080/` and generate 404 error for all other requests.

Replace

```js
app.use(function requestHandler(request, response) {
  response.send(
    "Hi everybody! This response gets sent with every client request"
  );
});
```

with

```js
app.get("/", function requestHandler(request, response) {
  response.send(
    "Hi everybody! This response only gets send when the client is at the root (/) of the page"
  );
});
```

Restart your server with `node server/index.js`. Then visit the following two different urls: `http://localhost:8080/` and `http://localhost:8080/randomnameforroute`. Only the root page (index) will show us the response message. All other requests will end up with 404 [HTTP status code](https://en.wikipedia.org/wiki/List_of_HTTP_status_codes).

> **Note** - in order to avoid restarting server manually every time we change the source code, we can use [nodemon](https://nodemon.io/) package. You can install it globally and use it instead of the `node` command when executing a Node.js file.
> `npm install --global nodemon`.
> Now you can use `nodemon server/index.js` to run and watch your Node.js files.

4. Now we can "teach" our server to handle different URLs and [HTTP methods](https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods) which together construct routes.

> _Routing_ refers to determining how an application responds to a client request to a particular endpoint (like `app.get("/")`). Each route can have one or more handler functions (that are callbacks), which are executed when the route is matched. For example, if a user goes to `http://somewebsite.com/` then the GET endpoint for `/` will be triggered and the route (all the request handler functions inside) will be executed.

```js
app.get("/", function requestHandler(request, response) {
  response.send("Going to http://somewebsite.com/ and this is the response!");
});
```

Route definition takes the following structure:

```js
router.METHOD(PATH, HANDLER, [HANDLER2, [HANDLER3,...]])
```

Routers can be nested. You can define router as a handler:

```js
const apiRouter = express.Router();

apiRouter.get("/", function(req, res) {
  res.send("triggered by GET /api/ path");
});

apiRouter.post("/add", function(req, res) {
  res.send("triggered by POST /api/add path");
});

app.use("/api", apiRouter);

app.get("/", function(req, res) {
  res.send("index page, triggered by GET /");
});
```

The code above will create 3 routes which can be triggered by the user that visits them from the browser. Any other route will generate 404 error (this is automatic behavior by Express).

```
GET /api
POST /api/add
GET /
```

> **Note 1** - The order is important. Routes defined first in the server-side code will trigger and be executed when it's a match.
>
> **Note 2** - Once a route handler is triggered, it will not proceed to another matching route handler, unless you use **next()** function. Next function is being provided as 3rd argument to handler functions, but it is optional and can therefore be left if not needed.
>
> ```js
> app.use("*", function logGetRequests(req, res, next) {
>   // if this is first declared route - you will see the following message on every GET request
>   console.log("someone made a request with GET method");
>   next(); // this function will pass execution to next matching route handler
> });
> ```
>
> **Note 3** - to understand better how Express works and the order of execution of your handlers it's advised to read more about [writing](https://expressjs.com/en/guide/writing-middleware.html) and [using](https://expressjs.com/en/guide/using-middleware.html) middleware functions.

> **Note** - A middleware is a function that modifies the `req` or `request` object with

### Recap Node base app

Let's recap how our `server/index.js` file content might look like:

```js
const express = require("express");

const app = express();

const apiRouter = express.Router();

app.use("*", function logGetRequests(req, res, next) {
  console.log("someone made a request with GET method");
  next();
});

apiRouter.get("/", function(req, res) {
  res.send("triggered by GET /api/");
});

apiRouter.post("/add", function(req, res) {
  res.send("triggered by POST /api/add");
});

app.use("/api", apiRouter);

app.get("/", function(req, res) {
  res.send("index page, triggered by GET /");
});

app.listen(8080);
```

If you open the `http://localhost:8080/` URL in the browser, you will see the `index page, triggered by GET /` message in the browser and `someone made a request with GET method` message in the CLI (which is where server-side messages are displayed).

You can also access following routes:

- GET `http://localhost:8080/api/`
- POST `http://localhost:8080/api/add`

### Creating our base React app

There are multiple ways of setting up a React environment, but for this project we'll be using `create-react-app`. Make sure you have installed it to your machine globally.

> **Note**: You can install `create-react-app` globally by using the following command in the CLI: `npm install -g create-react-app`

Make sure you are in the root of your project folder. Then execute the following command through the CLI: `create-react-app client`. This will create a `client/` folder in your project, including a basic React setup inside.

This is good for now, as we'll be working on the frontend during the upcoming weeks.

P.S This might be a good moment for another GIT commit. Make the message meaningful!

### Splitting your application code: folder organization

Although we can write all the code in one file, it will eventually become big, complex and unclear.

To get a better overview we can **split** the code into separate smaller files. Each file will then be responsible for providing the application a different functionality.

We will change the folder structure of `server/` into the following:

```
server/
	api/
		index.js - Contains all our routes and necessary logic
	app.js - Contains all our middlewares
	index.js - Contains the code that starts and runs our HTTP server
```

```js
// Path: server/index.js
// Purpose of file: To start our HTTP server
const app = require("./app"); // This loads in the code from app.js

app.listen(8080); // We can use that "app" functionality now in this file to start the server
```

```js
// Path: server/app.js
// Purpose of file: To initialize Express and create basic endpoints
const express = require("express"); // Loading in Express functionality

const apiRouter = require("./api"); // Loading in our custom index.js from /api (it will automatically look for index.js)

const app = express(); // Creating an Express instance

app.use("*", function logGetRequests(req, res, next) {
  console.log("someone made a request with GET method");
  next();
});

app.get("/api", apiRouter);

app.get("/", function(req, res) {
  res.send("index page, triggered by GET /");
});

module.exports = app;
```

```js
// Path: server/api/index.js
// Purpose of file: To contain all our routes and necessary logic
const apiRouter = require("express").Router();

apiRouter.get("/", function(req, res) {
  res.send("triggered by GET /api/ path");
});

apiRouter.post("/add", function(req, res) {
  res.send("triggered by POST /api/add path");
});

module.exports = apiRouter;
```

### Serving static files

When using Express, it needs to know in which folder you'll keep your static files (also known as assets).

Express provides [special middleware](https://expressjs.com/en/starter/static-files.html) which helps to serve static files requested by the client.

```js
express.static(root, [options]);
```

We can use static middleware to allow our http-server to send content of any requested static file from `root` folder.
For example, if we create `public/index.html` and `public/style.css` files we will be able to request them from browser directly. Let's try it:

Add this middleware before any route in `server/app.js`

```js
// server/app.js
const path = require("path");

app.use(express.static(path.join(__dirname, "public")));
```

> **Note** - path is a default nodejs package in older versions.

Create new `public/index.html` file

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Node App</title>
    <link rel="stylesheet" href="/style.css" />
  </head>
  <body>
    <h1>Home page</h1>
  </body>
</html>
```

Create new `public/style.css` file

```css
body {
  background: #f0f0f0;
  color: #444;
  font: normal 18px Arial, sans-serif;
}

h1 {
  color: red;
}
```

Now, accessing `http://localhost:8080/` will trigger static middleware to serve `public/index.html` file (if index.html file is available it gets served automatically) which will request `http://localhost:8080/style.css` (check the Network tab) and get content of `public/style.css`.

Note that our `app.get('/', ...);` route is not triggered anymore. Reason for that is, if express.static could find a file by requested name, next() function will NOT be called. If there is no such file, next() function will be executed. You can try it by accessing not existing asset, like `http://localhost:8080/app.js` and changing `app.get('/', ...);` to `app.get('*', ...);` for example. You will see "index page, triggered by GET /" message in browser.

---

### (OPTIONAL) Lint and format js/jsx

[eslint](https://eslint.org/) - js code linter

> Code linting is a type of static analysis that is frequently used to
> find problematic patterns or code that doesn’t adhere to certain style
> guidelines.

[prettier](https://prettier.io/) - an opinionated code formatter

Eslint will help us find and fix bad code patterns.
Prettier helps to focus on writing code, not styling it.

Both eslint and prettier have integration with most IDEs and code editors.

Run this command to install all packages needed for eslint and prettier setup.

```
npm install --save-dev eslint eslint-config-airbnb-base eslint-config-prettier eslint-plugin-import eslint-plugin-jsx-a11y eslint-plugin-prettier eslint-plugin-react prettier
```

Add the following content to **.eslintrc.json** file

```json
// .eslintrc.json
{
  "extends": [
    "airbnb-base",
    "plugin:react/recommended",
    "plugin:prettier/recommended"
  ],
  "rules": {
    "prettier/prettier": "error",
    "func-names": 0,
    "react/jsx-filename-extension": [
      1,
      {
        "extensions": [".js", ".jsx"]
      }
    ]
  },
  "env": {
    "browser": true,
    "node": true,
    "jasmine": true
  },
  "parserOptions": {
    "ecmaFeatures": {
      "jsx": true
    }
  }
}
```

and this code for **.prettierrc.json**

```json
// .prettierrc.json
{
  "trailingComma": "es5",
  "tabWidth": 4,
  "semi": true,
  "singleQuote": true
}
```

Next step would be to set up your code editor. You can download eslint and prettier plugins for it. Most likely those plugins will find and use config files we just created.

### Lint files automatically before commit.

To achieve this we can use [git hooks](https://git-scm.com/book/en/v2/Customizing-Git-Git-Hooks). **pre-commit** hook in particular.

Let's install following packages: **husky** and **lint-staged**

With **husky** we can specify commands we want to run on git hooks.
**lint-staged** helps to perform commands only on staged files (the ones that were staged with `git add` command.

```
npm install --save-dev husky lint-staged
```

To use husky, we can add following section in our **package.json** file:

```json
// package.json
"husky": {
    "hooks": {
        "pre-commit": "lint-staged"
    }
},
```

Similar for lint-staged:

```json
// package.json
"lint-staged": {
    "*.{js,jsx}": [
        "eslint",
        "git add"
    ]
},
```

Combination of these two sections will run eslint on all staged files, whenever we try to commit our changes.
If eslint finds errors, commit process will be aborted. In that case you would need to fix problems first and commit again.

This setup will allow you work in team with more confidence, have same code linting and formatting for every team member, and won't allow "bad code" to go to remote repo.

## Conclusion

Finished? Be proud of yourself, because you just setup a basic project folder! You are now completely able to start any web application project using Node.js in the backend and React in the frontend.

Be sure to commit everything you did to your remote repository. When you're finished put a link to it in your class Slack channel, so the teacher can see it.
